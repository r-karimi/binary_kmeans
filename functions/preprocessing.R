# This file contains functions to pre-process the raw tabular data from
# photobleaching experiments to detect subunit stoichiometry in DNA nanotubes.

## thresholding
# Arguments:
  # vec: A vector of fluorescence intensity values.
  # mean: A mean intensity value.
  # std: A standard deviation.
# Returns:
  # A logical vector of length(vec).
# Description:
  # The thresholding function is a short function to return a logical vector
  # defining the signal-containing region and the noise-containing region
  # of the time-intensity trace.

thresholding = function(vec, mean, std){
  return(abs(vec - mean) >=  5*std)
}

## find_window
# Arguments:
  # data: An N x 2 data frame of time and intensity values as 
  # generated by a photodetector.
# Returns:
  # A trimmed M x 2 data frame where the zero-mean noise at the end of the 
  # intensity-time trace has been removed, except for the first ten 
  # time-intensity tuples of this noise section.
# Description: 
  # The find_window function preprocesses a data frame of time-intensity tuples, 
  # to automatically detect the region of the time-intensity trace that contains 
  # the photobleaching signal. It does so by reversing the time-intensity trace, 
  # using the first 25 time-intensity tuples of the reversed trace to compute a 
  # mean and standard deviation of the background noise, and then find and 
  # return the regions that are greater than five standard deviations from 
  # the mean of the background noise.

find_window = function(data){
  
  # Find the mean and std of the last 25 observations
  threshold = data[,2] %>% # Isolate the intensity vector
    map(rev) %>% # Reverse it
    unlist(recursive = F) %>%
    as_tibble() %>%
    slice(1:25) %>% # Isolate the first 25 intensity values
    summarise(mean = mean(value), 
              std = sd(value)) # Compute the mean and s.d.
  
  data = data %>% 
    mutate(noise = thresholding(intensity, 
                                threshold$mean, 
                                threshold$std)) %>% # Define a third logical 
    # column defining the regions that are signal and noise using 
    # the thresholding helper function
    slice(1:(sum(noise) + 10)) # Isolate the data frame to the region 
    # that is signal, plus ten data points from the noise
  
  data = data[,-c(3)] # Remove the logical column
  
  return(data) # Return the trimmed data frame
}

## pre_process
# Arguments:
  # data: An M x 2 data frame of time and intensity values as generated by a photodetector.
# Returns:
  # A two item list of:
    # 1) A scaled M x 2 data frame of time-intensity tuples
    # 2) A scaling factor for future un-transformation of the data, defined as max(data$time)/max(data$intensity)
# Description: 
# The pre_process function "squares" the time-intensity tuples by applying 
# a transformation to the intensity values of the data frame, such that 
# the maximum time and intensity values are the same. 
# This is done to weight the time and intensity dimensions equally 
# in the Euclidean distance metric used in the K-means clustering algorithm.

pre_process = function(data){
  scale = max(data$time)/max(data$intensity) # Compute the scaling factor
  scaled_data = data %>% 
    transmute(time = time, 
              intensity = intensity*scale) # Transform intensities
  list(data = scaled_data, scale = scale) %>% return() # Create a list and return
}

## pre_clust
# Arguments:
  # data: An M x 2 data frame of time and intensity values as generated by a photodetector.
# Returns:
  # A nested data frame of clusters marked for reclustering with the shap variable.
# Description: 
  # This function takes a data frame of time-intensity tuples and returns a
  # nested data frame containing the time-intensity tuples and a marker
  # variable, shap, indicating whether the cluster must undergo binary
  # segmentation in the next run of the algorithm. Since this function
  # aims just to wrangle the raw data into the format necessary for
  # iterative binary segmentation, there is just one cluster in the
  # nested data frame.

pre_clust = function(data){
  data %>%
    mutate(.cluster = 1) %>% # Add a cluster number variable
    group_by(.cluster) %>% # Group by cluster number
    nest() %>%
    mutate(shap = map(data, shapiro_helper)) %>% # Apply the shapiro helper function to each cluster
    mutate(reclust = ifelse(shap <= 0.05, T, F)) %>% # Mark the cluster for reclustering if the p-value of the Shapiro-Wilk test is less than 0.05
    return()
}